@page "/{*path}"
@inject NavigationManager Navigation
@using PersonalWebsite.Components.GitHubLink
@inherits BasePage

<h3>Page Not Found</h3>
<GitHubLink FullURL="@GitHubLinkUrl" />

@if (redirectTarget != null)
{
    <p>Redirecting to <strong>@redirectTarget</strong>...</p>
}
else if (suggestedTargets.Count > 1)
{
    <p>Did you mean one of the following?</p>
    <ul>
        @foreach (var match in suggestedTargets)
        {
            var detectedBasePath = UrlBase(false);
            if (string.IsNullOrEmpty(detectedBasePath))
            {
                <li>ERROR: @($"[{detectedBasePath}] [{match.Path}] - [{match.Title}]")</li>
            }
            <li><a href="@($"{detectedBasePath}{match.Path}")">@match.Title</a></li>
        }
    </ul>
}
else
{
    <p>We couldn't find the page <strong>@path</strong>.</p>
    <p><a href="">Return to Home</a></p>
}

@code {
    [Parameter]
    public string? path { get; set; }

    protected override string FilePath => "Pages/NotFound/NotFound.razor";
    private string? redirectTarget;
    private List<(string Title, string Path)> suggestedTargets = new();

    private static Dictionary<string, string> knownRoutes = new(StringComparer.OrdinalIgnoreCase)
    {
        { "ai-training", "/ai-training" },
        { "training", "/ai-training" },
        { "workshops", "/ai-training" },
        { "connect-collaborate", "/connect-collaborate" },
        { "consulting", "/consulting" },
        { "contact", "/contact" },
        { "curriculum-samples", "/curriculum-samples" },
        { "infrastructure-legacy-systems-engineering-addendum", "/infrastructure-legacy-systems-engineering-addendum" },
        { "it-works", "/it-works" },
        { "itworks", "/it-works" },
        { "legacy-engineering-texaco", "/legacy-engineering-texaco" },
        { "legacy-profile", "/legacy-profile" },
        { "legacy-profile-document", "/legacy-profile-document" },
        { "myblogs", "/myblogs" },
        { "myprojects", "/myprojects" },
        { "myrecommendations", "/myrecommendations" },
        { "offerings", "/offerings" },
        { "problem-solving-profile-document", "/problem-solving-profile-document" },
        { "professionalsummary", "/professionalsummary" },
        { "resume-architect", "/resume-architect" },
        { "resume-engineer", "/resume-engineer" },
        { "resume-manager", "/resume-manager" },
        { "resumes", "/resumes" },
        { "software", "/software" },
        { "version", "/version" },
        { "workflow-modernization", "/workflow-modernization" },
        { "home", "/" },
        { "", "/" }
    };

    private static readonly Dictionary<string, string> routeTitles = new(StringComparer.OrdinalIgnoreCase)
    {
        { "ai-training", "AI Training & Workshops" },
        { "connect-collaborate", "Connect & Collaborate" },
        { "consulting", "Consulting Services" },
        { "contact", "Contact Me" },
        { "curriculum-samples", "Curriculum Samples" },
        { "infrastructure-legacy-systems-engineering-addendum", "Infrastructure & Legacy Systems Addendum" },
        { "it-works", "IT Works Suite" },
        { "legacy-engineering-texaco", "Legacy Engineering at Texaco" },
        { "legacy-profile", "Legacy Profile" },
        { "legacy-profile-document", "Legacy Profile Document" },
        { "myblogs", "My Blog Posts" },
        { "myprojects", "My Projects" },
        { "myrecommendations", "My Recommendations" },
        { "offerings", "Service Offerings" },
        { "problem-solving-profile-document", "Problem Solving Profile Document" },
        { "professionalsummary", "Professional Summary" },
        { "resume-architect", "Architect Resume" },
        { "resume-engineer", "Engineer Resume" },
        { "resume-manager", "Manager Resume" },
        { "resumes", "All Resumes" },
        { "software", "Software Portfolio" },
        { "version", "Version Info" },
        { "workflow-modernization", "Workflow Modernization" },
        { "home", "Home" },
        { "", "Home" }
    };

    protected override async Task OnInitializedAsync()
    {
        var uri = new Uri(Navigation.Uri);
        var fullPath = uri.AbsolutePath.Trim('/');
        var query = uri.Query;       // Includes leading '?'
        var fragment = uri.Fragment; // Includes leading '#'
        var detectedBasePath = UrlBase(false);

        await LogToConsole($"NotFound activated for: {uri} ...");
        await LogToConsole($"fullPath: {fullPath} ...");
        await LogToConsole($"query: {query} ...");
        await LogToConsole($"fragment: {fragment} ...");
        if (string.IsNullOrWhiteSpace(path))
        {
            await LogToConsole($"Navigating to query (No Path) {detectedBasePath}/{query}{fragment} ...");
            Navigation.NavigateTo($"{detectedBasePath}/{query}{fragment}");
            return;
        }

        // Direct match
        if (knownRoutes.TryGetValue(path, out var target))
        {
            redirectTarget = $"{detectedBasePath}/{target}{query}{fragment}";
            await LogToConsole($"Navigating to Direct Match {redirectTarget} ...");
            Navigation.NavigateTo(redirectTarget);
            return;
        }

        // Fuzzy match
        await LogToConsole($"FindClosestMatch: {path} ...");
        suggestedTargets = FindClosestMatches(path, knownRoutes);
        await LogToConsole($"FindClosestMatch: {path} found {string.Join(", ", suggestedTargets.Select(match => match.Title))} ...");
        if (suggestedTargets.Count == 1)
        {
            var singleTarget = suggestedTargets[0].Path;
            redirectTarget = $"{detectedBasePath}/{singleTarget}{query}{fragment}";
            await LogToConsole($"Navigating to Single Closest Match {redirectTarget} ...");
            Navigation.NavigateTo(redirectTarget);
            return;
        }
        if (suggestedTargets.Count == 0)
        {
            await LogToConsole($"NotFound dropped out. No suggestions: {uri} ...");
        }
        else
        {
            await LogToConsole($"NotFound dropped out. Multiple suggestions: {uri} ...");
        }
    }

    private static List<(string Title, string Path)> FindClosestMatches(string input, Dictionary<string, string> routes)
    {
        string Normalize(string s) =>
            new string(s.Where(char.IsLetterOrDigit).ToArray()).ToLowerInvariant();

        var normalizedInput = Normalize(input);

        // Prefix matches
        var prefixMatches = routes
            .Where(kvp => Normalize(kvp.Key).StartsWith(normalizedInput))
            .Select(kvp => (
                Title: routeTitles.TryGetValue(kvp.Key, out var title) ? title : kvp.Key,
                Path: kvp.Value))
            .ToList();

        if (prefixMatches.Any())
            return prefixMatches;

        // Levenshtein matches (top 3)
        var fuzzyMatches = routes
            .Select(kvp => new {
                kvp.Key,
                kvp.Value,
                distance = LevenshteinDistance(normalizedInput, Normalize(kvp.Key))
            })
            .OrderBy(x => x.distance)
            .Take(3)
            .Select(x => (
                Title: routeTitles.TryGetValue(x.Key, out var title) ? title : x.Key,
                Path: x.Value))
            .ToList();

        return fuzzyMatches;
    }

    // Simple Levenshtein Distance implementation
    private static int LevenshteinDistance(string s, string t)
    {
        var n = s.Length;
        var m = t.Length;
        var d = new int[n + 1, m + 1];

        for (int i = 0; i <= n; i++) d[i, 0] = i;
        for (int j = 0; j <= m; j++) d[0, j] = j;

        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                int cost = s[i - 1] == t[j - 1] ? 0 : 1;
                d[i, j] = Math.Min(
                    Math.Min(d[i - 1, j] + 1, d[i, j - 1] + 1),
                    d[i - 1, j - 1] + cost);
            }
        }

        return d[n, m];
    }
}
