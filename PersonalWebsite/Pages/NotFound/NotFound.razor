@page "/{*path}"
@inject NavigationManager Navigation
@using PersonalWebsite.Components.GitHubLink
@inherits BasePage

<h3>Page Not Found</h3>
<GitHubLink FullURL="@GitHubLinkUrl" />

@if (redirectTarget != null)
{
    <p>Redirecting to <strong>@redirectTarget</strong>...</p>
}
else if (suggestedTargets.Count > 1)
{
    <p>Did you mean one of the following?</p>
    <ul>
        @foreach (var match in suggestedTargets)
        {
            <li>
                <NavLink href="@match.Path" Match="NavLinkMatch.Prefix">
                    @match.Title
                </NavLink>
            </li>
        }
    </ul>
}
else
{
    <p>We couldn't find the page <strong>@path</strong>.</p>
    <p><a href="">Return to Home</a></p>
}

@code {
    [Parameter]
    public string? path { get; set; }

    protected override string FilePath => "Pages/NotFound/NotFound.razor";
    private string? redirectTarget;
    private List<(string Title, string Path)> suggestedTargets = new();

    private static Dictionary<string, string> knownRoutes = new(StringComparer.OrdinalIgnoreCase)
    {
        { "ai-training", "ai-training" },
        { "training", "ai-training" },
        { "workshops", "ai-training" },
        { "connect-collaborate", "connect-collaborate" },
        { "consulting", "consulting" },
        { "contact", "contact" },
        { "curriculum-samples", "curriculum-samples" },
        { "infrastructure-legacy-systems-engineering-addendum", "infrastructure-legacy-systems-engineering-addendum" },
        { "it-works", "it-works" },
        { "itworks", "it-works" },
        { "legacy-engineering-texaco", "legacy-engineering-texaco" },
        { "legacy-profile", "legacy-profile" },
        { "legacy-profile-document", "legacy-profile-document" },
        { "myblogs", "myblogs" },
        { "myprojects", "myprojects" },
        { "myrecommendations", "myrecommendations" },
        { "offerings", "offerings" },
        { "problem-solving-profile-document", "problem-solving-profile-document" },
        { "professionalsummary", "professionalsummary" },
        { "resume-architect", "resume-architect" },
        { "resume-engineer", "resume-engineer" },
        { "resume-manager", "resume-manager" },
        { "resumes", "resumes" },
        { "software", "software" },
        { "version", "version" },
        { "workflow-modernization", "workflow-modernization" },
        { "home", "" },
        { "", "" }
    };

    private static readonly Dictionary<string, string> routeTitles = new(StringComparer.OrdinalIgnoreCase)
    {
        { "ai-training", "AI Training & Workshops" },
        { "connect-collaborate", "Connect & Collaborate" },
        { "consulting", "Consulting Services" },
        { "contact", "Contact Me" },
        { "curriculum-samples", "Curriculum Samples" },
        { "infrastructure-legacy-systems-engineering-addendum", "Infrastructure & Legacy Systems Addendum" },
        { "it-works", "IT Works Suite" },
        { "legacy-engineering-texaco", "Legacy Engineering at Texaco" },
        { "legacy-profile", "Legacy Profile" },
        { "legacy-profile-document", "Legacy Profile Document" },
        { "myblogs", "My Blog Posts" },
        { "myprojects", "My Projects" },
        { "myrecommendations", "My Recommendations" },
        { "offerings", "Service Offerings" },
        { "problem-solving-profile-document", "Problem Solving Profile Document" },
        { "professionalsummary", "Professional Summary" },
        { "resume-architect", "Architect Resume" },
        { "resume-engineer", "Engineer Resume" },
        { "resume-manager", "Manager Resume" },
        { "resumes", "All Resumes" },
        { "software", "Software Portfolio" },
        { "version", "Version Info" },
        { "workflow-modernization", "Workflow Modernization" },
        { "home", "Home" },
        { "", "Home" }
    };

    protected override async Task OnInitializedAsync()
    {
        var uri = new Uri(Navigation.Uri);
        var fullPath = uri.AbsolutePath.Trim('/');
        var query = uri.Query;       // Includes leading '?'
        var fragment = uri.Fragment; // Includes leading '#'

        await LogToConsole($"NotFound activated for: {uri} ...");
        await LogToConsole($"fullPath: {fullPath} ...");
        await LogToConsole($"query: {query} ...");
        await LogToConsole($"fragment: {fragment} ...");
        if (string.IsNullOrWhiteSpace(path))
        {
            await LogToConsole($"Navigating to query (No Path) {query}{fragment} ...");
            Navigation.NavigateTo($"{query}{fragment}");
            return;
        }

        // Direct match
        if (knownRoutes.TryGetValue(path, out var target))
        {
            redirectTarget = $"{target}{query}{fragment}";
            await LogToConsole($"Navigating to Direct Match {redirectTarget} ...");
            Navigation.NavigateTo(redirectTarget);
            return;
        }

        // Fuzzy match
        await LogToConsole($"FindClosestMatch: {path} ...");
        suggestedTargets = FindClosestMatches(path, knownRoutes);
        await LogToConsole($"FindClosestMatch: {path} found {string.Join(", ", suggestedTargets.Select(match => match.Title))} ...");
        if (suggestedTargets.Count == 1)
        {
            var singleTarget = suggestedTargets[0].Path;
            redirectTarget = $"{singleTarget}{query}{fragment}";
            await LogToConsole($"Navigating to Single Closest Match {redirectTarget} ...");
            Navigation.NavigateTo(redirectTarget);
            return;
        }
        if (suggestedTargets.Count == 0)
        {
            await LogToConsole($"NotFound dropped out. No suggestions: {uri} ...");
        }
        else
        {
            await LogToConsole($"NotFound dropped out. Multiple suggestions: {uri} ...");
        }
    }

    private static List<(string Title, string Path)> FindClosestMatches(string input, Dictionary<string, string> routes)
    {
        string Normalize(string s) =>
            new string(s.Where(char.IsLetterOrDigit).ToArray()).ToLowerInvariant();

        var normalizedInput = Normalize(input);

        // Substring (contains) matches
        var containsMatches = routes
            .Select(kvp => new
            {
                Key = kvp.Key,
                Path = kvp.Value,
                NormalizedKey = Normalize(kvp.Key)
            })
            .Where(x => x.NormalizedKey.Contains(normalizedInput))
            .Select(x => (
                Title: routeTitles.TryGetValue(x.Key, out var title) ? title : x.Key,
                Path: x.Path))
            .ToList();

        if (containsMatches.Any())
            return containsMatches;

        // Levenshtein fallback (top 3)
        var fuzzyMatches = routes
            .Select(kvp => new
            {
                Key = kvp.Key,
                Path = kvp.Value,
                Distance = LevenshteinDistance(normalizedInput, Normalize(kvp.Key))
            })
            .OrderBy(x => x.Distance)
            .Take(3)
            .Select(x => (
                Title: routeTitles.TryGetValue(x.Key, out var title) ? title : x.Key,
                Path: x.Path))
            .ToList();

        return fuzzyMatches;
    }

    // Simple Levenshtein Distance implementation
    private static int LevenshteinDistance(string s, string t)
    {
        var n = s.Length;
        var m = t.Length;
        var d = new int[n + 1, m + 1];

        for (int i = 0; i <= n; i++) d[i, 0] = i;
        for (int j = 0; j <= m; j++) d[0, j] = j;

        for (int i = 1; i <= n; i++)
        {
            for (int j = 1; j <= m; j++)
            {
                int cost = s[i - 1] == t[j - 1] ? 0 : 1;
                d[i, j] = Math.Min(
                    Math.Min(d[i - 1, j] + 1, d[i, j - 1] + 1),
                    d[i - 1, j - 1] + cost);
            }
        }

        return d[n, m];
    }
}
